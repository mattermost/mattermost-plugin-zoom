// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make pluginapi"
// DO NOT EDIT

package plugin

import (
	"fmt"
	"log"

	"github.com/mattermost/mattermost-server/mlog"
	"github.com/mattermost/mattermost-server/model"
)

func init() {
	hookNameToId["OnDeactivate"] = OnDeactivateId
}

type Z_OnDeactivateArgs struct {
}

type Z_OnDeactivateReturns struct {
	A error
}

func (g *hooksRPCClient) OnDeactivate() error {
	_args := &Z_OnDeactivateArgs{}
	_returns := &Z_OnDeactivateReturns{}
	if g.implemented[OnDeactivateId] {
		if err := g.client.Call("Plugin.OnDeactivate", _args, _returns); err != nil {
			g.log.Error("RPC call OnDeactivate to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) OnDeactivate(args *Z_OnDeactivateArgs, returns *Z_OnDeactivateReturns) error {
	if hook, ok := s.impl.(interface {
		OnDeactivate() error
	}); ok {
		returns.A = hook.OnDeactivate()
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("Hook OnDeactivate called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["OnConfigurationChange"] = OnConfigurationChangeId
}

type Z_OnConfigurationChangeArgs struct {
}

type Z_OnConfigurationChangeReturns struct {
	A error
}

func (g *hooksRPCClient) OnConfigurationChange() error {
	_args := &Z_OnConfigurationChangeArgs{}
	_returns := &Z_OnConfigurationChangeReturns{}
	if g.implemented[OnConfigurationChangeId] {
		if err := g.client.Call("Plugin.OnConfigurationChange", _args, _returns); err != nil {
			g.log.Error("RPC call OnConfigurationChange to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) OnConfigurationChange(args *Z_OnConfigurationChangeArgs, returns *Z_OnConfigurationChangeReturns) error {
	if hook, ok := s.impl.(interface {
		OnConfigurationChange() error
	}); ok {
		returns.A = hook.OnConfigurationChange()
		returns.A = encodableError(returns.A)
	} else {
		return encodableError(fmt.Errorf("Hook OnConfigurationChange called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["ExecuteCommand"] = ExecuteCommandId
}

type Z_ExecuteCommandArgs struct {
	A *Context
	B *model.CommandArgs
}

type Z_ExecuteCommandReturns struct {
	A *model.CommandResponse
	B *model.AppError
}

func (g *hooksRPCClient) ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError) {
	_args := &Z_ExecuteCommandArgs{c, args}
	_returns := &Z_ExecuteCommandReturns{}
	if g.implemented[ExecuteCommandId] {
		if err := g.client.Call("Plugin.ExecuteCommand", _args, _returns); err != nil {
			g.log.Error("RPC call ExecuteCommand to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A, _returns.B
}

func (s *hooksRPCServer) ExecuteCommand(args *Z_ExecuteCommandArgs, returns *Z_ExecuteCommandReturns) error {
	if hook, ok := s.impl.(interface {
		ExecuteCommand(c *Context, args *model.CommandArgs) (*model.CommandResponse, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.ExecuteCommand(args.A, args.B)

	} else {
		return encodableError(fmt.Errorf("Hook ExecuteCommand called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["MessageWillBePosted"] = MessageWillBePostedId
}

type Z_MessageWillBePostedArgs struct {
	A *Context
	B *model.Post
}

type Z_MessageWillBePostedReturns struct {
	A *model.Post
	B string
}

func (g *hooksRPCClient) MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string) {
	_args := &Z_MessageWillBePostedArgs{c, post}
	_returns := &Z_MessageWillBePostedReturns{}
	if g.implemented[MessageWillBePostedId] {
		if err := g.client.Call("Plugin.MessageWillBePosted", _args, _returns); err != nil {
			g.log.Error("RPC call MessageWillBePosted to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A, _returns.B
}

func (s *hooksRPCServer) MessageWillBePosted(args *Z_MessageWillBePostedArgs, returns *Z_MessageWillBePostedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageWillBePosted(c *Context, post *model.Post) (*model.Post, string)
	}); ok {
		returns.A, returns.B = hook.MessageWillBePosted(args.A, args.B)

	} else {
		return encodableError(fmt.Errorf("Hook MessageWillBePosted called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["MessageWillBeUpdated"] = MessageWillBeUpdatedId
}

type Z_MessageWillBeUpdatedArgs struct {
	A *Context
	B *model.Post
	C *model.Post
}

type Z_MessageWillBeUpdatedReturns struct {
	A *model.Post
	B string
}

func (g *hooksRPCClient) MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string) {
	_args := &Z_MessageWillBeUpdatedArgs{c, newPost, oldPost}
	_returns := &Z_MessageWillBeUpdatedReturns{}
	if g.implemented[MessageWillBeUpdatedId] {
		if err := g.client.Call("Plugin.MessageWillBeUpdated", _args, _returns); err != nil {
			g.log.Error("RPC call MessageWillBeUpdated to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A, _returns.B
}

func (s *hooksRPCServer) MessageWillBeUpdated(args *Z_MessageWillBeUpdatedArgs, returns *Z_MessageWillBeUpdatedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageWillBeUpdated(c *Context, newPost, oldPost *model.Post) (*model.Post, string)
	}); ok {
		returns.A, returns.B = hook.MessageWillBeUpdated(args.A, args.B, args.C)

	} else {
		return encodableError(fmt.Errorf("Hook MessageWillBeUpdated called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["MessageHasBeenPosted"] = MessageHasBeenPostedId
}

type Z_MessageHasBeenPostedArgs struct {
	A *Context
	B *model.Post
}

type Z_MessageHasBeenPostedReturns struct {
}

func (g *hooksRPCClient) MessageHasBeenPosted(c *Context, post *model.Post) {
	_args := &Z_MessageHasBeenPostedArgs{c, post}
	_returns := &Z_MessageHasBeenPostedReturns{}
	if g.implemented[MessageHasBeenPostedId] {
		if err := g.client.Call("Plugin.MessageHasBeenPosted", _args, _returns); err != nil {
			g.log.Error("RPC call MessageHasBeenPosted to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) MessageHasBeenPosted(args *Z_MessageHasBeenPostedArgs, returns *Z_MessageHasBeenPostedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageHasBeenPosted(c *Context, post *model.Post)
	}); ok {
		hook.MessageHasBeenPosted(args.A, args.B)

	} else {
		return encodableError(fmt.Errorf("Hook MessageHasBeenPosted called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["MessageHasBeenUpdated"] = MessageHasBeenUpdatedId
}

type Z_MessageHasBeenUpdatedArgs struct {
	A *Context
	B *model.Post
	C *model.Post
}

type Z_MessageHasBeenUpdatedReturns struct {
}

func (g *hooksRPCClient) MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post) {
	_args := &Z_MessageHasBeenUpdatedArgs{c, newPost, oldPost}
	_returns := &Z_MessageHasBeenUpdatedReturns{}
	if g.implemented[MessageHasBeenUpdatedId] {
		if err := g.client.Call("Plugin.MessageHasBeenUpdated", _args, _returns); err != nil {
			g.log.Error("RPC call MessageHasBeenUpdated to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) MessageHasBeenUpdated(args *Z_MessageHasBeenUpdatedArgs, returns *Z_MessageHasBeenUpdatedReturns) error {
	if hook, ok := s.impl.(interface {
		MessageHasBeenUpdated(c *Context, newPost, oldPost *model.Post)
	}); ok {
		hook.MessageHasBeenUpdated(args.A, args.B, args.C)

	} else {
		return encodableError(fmt.Errorf("Hook MessageHasBeenUpdated called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["ChannelHasBeenCreated"] = ChannelHasBeenCreatedId
}

type Z_ChannelHasBeenCreatedArgs struct {
	A *Context
	B *model.Channel
}

type Z_ChannelHasBeenCreatedReturns struct {
}

func (g *hooksRPCClient) ChannelHasBeenCreated(c *Context, channel *model.Channel) {
	_args := &Z_ChannelHasBeenCreatedArgs{c, channel}
	_returns := &Z_ChannelHasBeenCreatedReturns{}
	if g.implemented[ChannelHasBeenCreatedId] {
		if err := g.client.Call("Plugin.ChannelHasBeenCreated", _args, _returns); err != nil {
			g.log.Error("RPC call ChannelHasBeenCreated to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) ChannelHasBeenCreated(args *Z_ChannelHasBeenCreatedArgs, returns *Z_ChannelHasBeenCreatedReturns) error {
	if hook, ok := s.impl.(interface {
		ChannelHasBeenCreated(c *Context, channel *model.Channel)
	}); ok {
		hook.ChannelHasBeenCreated(args.A, args.B)

	} else {
		return encodableError(fmt.Errorf("Hook ChannelHasBeenCreated called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasJoinedChannel"] = UserHasJoinedChannelId
}

type Z_UserHasJoinedChannelArgs struct {
	A *Context
	B *model.ChannelMember
	C *model.User
}

type Z_UserHasJoinedChannelReturns struct {
}

func (g *hooksRPCClient) UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User) {
	_args := &Z_UserHasJoinedChannelArgs{c, channelMember, actor}
	_returns := &Z_UserHasJoinedChannelReturns{}
	if g.implemented[UserHasJoinedChannelId] {
		if err := g.client.Call("Plugin.UserHasJoinedChannel", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasJoinedChannel to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasJoinedChannel(args *Z_UserHasJoinedChannelArgs, returns *Z_UserHasJoinedChannelReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasJoinedChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	}); ok {
		hook.UserHasJoinedChannel(args.A, args.B, args.C)

	} else {
		return encodableError(fmt.Errorf("Hook UserHasJoinedChannel called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasLeftChannel"] = UserHasLeftChannelId
}

type Z_UserHasLeftChannelArgs struct {
	A *Context
	B *model.ChannelMember
	C *model.User
}

type Z_UserHasLeftChannelReturns struct {
}

func (g *hooksRPCClient) UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User) {
	_args := &Z_UserHasLeftChannelArgs{c, channelMember, actor}
	_returns := &Z_UserHasLeftChannelReturns{}
	if g.implemented[UserHasLeftChannelId] {
		if err := g.client.Call("Plugin.UserHasLeftChannel", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasLeftChannel to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasLeftChannel(args *Z_UserHasLeftChannelArgs, returns *Z_UserHasLeftChannelReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasLeftChannel(c *Context, channelMember *model.ChannelMember, actor *model.User)
	}); ok {
		hook.UserHasLeftChannel(args.A, args.B, args.C)

	} else {
		return encodableError(fmt.Errorf("Hook UserHasLeftChannel called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasJoinedTeam"] = UserHasJoinedTeamId
}

type Z_UserHasJoinedTeamArgs struct {
	A *Context
	B *model.TeamMember
	C *model.User
}

type Z_UserHasJoinedTeamReturns struct {
}

func (g *hooksRPCClient) UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User) {
	_args := &Z_UserHasJoinedTeamArgs{c, teamMember, actor}
	_returns := &Z_UserHasJoinedTeamReturns{}
	if g.implemented[UserHasJoinedTeamId] {
		if err := g.client.Call("Plugin.UserHasJoinedTeam", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasJoinedTeam to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasJoinedTeam(args *Z_UserHasJoinedTeamArgs, returns *Z_UserHasJoinedTeamReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasJoinedTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	}); ok {
		hook.UserHasJoinedTeam(args.A, args.B, args.C)

	} else {
		return encodableError(fmt.Errorf("Hook UserHasJoinedTeam called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasLeftTeam"] = UserHasLeftTeamId
}

type Z_UserHasLeftTeamArgs struct {
	A *Context
	B *model.TeamMember
	C *model.User
}

type Z_UserHasLeftTeamReturns struct {
}

func (g *hooksRPCClient) UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User) {
	_args := &Z_UserHasLeftTeamArgs{c, teamMember, actor}
	_returns := &Z_UserHasLeftTeamReturns{}
	if g.implemented[UserHasLeftTeamId] {
		if err := g.client.Call("Plugin.UserHasLeftTeam", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasLeftTeam to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasLeftTeam(args *Z_UserHasLeftTeamArgs, returns *Z_UserHasLeftTeamReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasLeftTeam(c *Context, teamMember *model.TeamMember, actor *model.User)
	}); ok {
		hook.UserHasLeftTeam(args.A, args.B, args.C)

	} else {
		return encodableError(fmt.Errorf("Hook UserHasLeftTeam called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserWillLogIn"] = UserWillLogInId
}

type Z_UserWillLogInArgs struct {
	A *Context
	B *model.User
}

type Z_UserWillLogInReturns struct {
	A string
}

func (g *hooksRPCClient) UserWillLogIn(c *Context, user *model.User) string {
	_args := &Z_UserWillLogInArgs{c, user}
	_returns := &Z_UserWillLogInReturns{}
	if g.implemented[UserWillLogInId] {
		if err := g.client.Call("Plugin.UserWillLogIn", _args, _returns); err != nil {
			g.log.Error("RPC call UserWillLogIn to plugin failed.", mlog.Err(err))
		}
	}
	return _returns.A
}

func (s *hooksRPCServer) UserWillLogIn(args *Z_UserWillLogInArgs, returns *Z_UserWillLogInReturns) error {
	if hook, ok := s.impl.(interface {
		UserWillLogIn(c *Context, user *model.User) string
	}); ok {
		returns.A = hook.UserWillLogIn(args.A, args.B)

	} else {
		return encodableError(fmt.Errorf("Hook UserWillLogIn called but not implemented."))
	}
	return nil
}

func init() {
	hookNameToId["UserHasLoggedIn"] = UserHasLoggedInId
}

type Z_UserHasLoggedInArgs struct {
	A *Context
	B *model.User
}

type Z_UserHasLoggedInReturns struct {
}

func (g *hooksRPCClient) UserHasLoggedIn(c *Context, user *model.User) {
	_args := &Z_UserHasLoggedInArgs{c, user}
	_returns := &Z_UserHasLoggedInReturns{}
	if g.implemented[UserHasLoggedInId] {
		if err := g.client.Call("Plugin.UserHasLoggedIn", _args, _returns); err != nil {
			g.log.Error("RPC call UserHasLoggedIn to plugin failed.", mlog.Err(err))
		}
	}

}

func (s *hooksRPCServer) UserHasLoggedIn(args *Z_UserHasLoggedInArgs, returns *Z_UserHasLoggedInReturns) error {
	if hook, ok := s.impl.(interface {
		UserHasLoggedIn(c *Context, user *model.User)
	}); ok {
		hook.UserHasLoggedIn(args.A, args.B)

	} else {
		return encodableError(fmt.Errorf("Hook UserHasLoggedIn called but not implemented."))
	}
	return nil
}

type Z_RegisterCommandArgs struct {
	A *model.Command
}

type Z_RegisterCommandReturns struct {
	A error
}

func (g *apiRPCClient) RegisterCommand(command *model.Command) error {
	_args := &Z_RegisterCommandArgs{command}
	_returns := &Z_RegisterCommandReturns{}
	if err := g.client.Call("Plugin.RegisterCommand", _args, _returns); err != nil {
		log.Printf("RPC call to RegisterCommand API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RegisterCommand(args *Z_RegisterCommandArgs, returns *Z_RegisterCommandReturns) error {
	if hook, ok := s.impl.(interface {
		RegisterCommand(command *model.Command) error
	}); ok {
		returns.A = hook.RegisterCommand(args.A)
	} else {
		return encodableError(fmt.Errorf("API RegisterCommand called but not implemented."))
	}
	return nil
}

type Z_UnregisterCommandArgs struct {
	A string
	B string
}

type Z_UnregisterCommandReturns struct {
	A error
}

func (g *apiRPCClient) UnregisterCommand(teamId, trigger string) error {
	_args := &Z_UnregisterCommandArgs{teamId, trigger}
	_returns := &Z_UnregisterCommandReturns{}
	if err := g.client.Call("Plugin.UnregisterCommand", _args, _returns); err != nil {
		log.Printf("RPC call to UnregisterCommand API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) UnregisterCommand(args *Z_UnregisterCommandArgs, returns *Z_UnregisterCommandReturns) error {
	if hook, ok := s.impl.(interface {
		UnregisterCommand(teamId, trigger string) error
	}); ok {
		returns.A = hook.UnregisterCommand(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UnregisterCommand called but not implemented."))
	}
	return nil
}

type Z_GetSessionArgs struct {
	A string
}

type Z_GetSessionReturns struct {
	A *model.Session
	B *model.AppError
}

func (g *apiRPCClient) GetSession(sessionId string) (*model.Session, *model.AppError) {
	_args := &Z_GetSessionArgs{sessionId}
	_returns := &Z_GetSessionReturns{}
	if err := g.client.Call("Plugin.GetSession", _args, _returns); err != nil {
		log.Printf("RPC call to GetSession API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetSession(args *Z_GetSessionArgs, returns *Z_GetSessionReturns) error {
	if hook, ok := s.impl.(interface {
		GetSession(sessionId string) (*model.Session, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetSession(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetSession called but not implemented."))
	}
	return nil
}

type Z_GetConfigArgs struct {
}

type Z_GetConfigReturns struct {
	A *model.Config
}

func (g *apiRPCClient) GetConfig() *model.Config {
	_args := &Z_GetConfigArgs{}
	_returns := &Z_GetConfigReturns{}
	if err := g.client.Call("Plugin.GetConfig", _args, _returns); err != nil {
		log.Printf("RPC call to GetConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetConfig(args *Z_GetConfigArgs, returns *Z_GetConfigReturns) error {
	if hook, ok := s.impl.(interface {
		GetConfig() *model.Config
	}); ok {
		returns.A = hook.GetConfig()
	} else {
		return encodableError(fmt.Errorf("API GetConfig called but not implemented."))
	}
	return nil
}

type Z_SaveConfigArgs struct {
	A *model.Config
}

type Z_SaveConfigReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) SaveConfig(config *model.Config) *model.AppError {
	_args := &Z_SaveConfigArgs{config}
	_returns := &Z_SaveConfigReturns{}
	if err := g.client.Call("Plugin.SaveConfig", _args, _returns); err != nil {
		log.Printf("RPC call to SaveConfig API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SaveConfig(args *Z_SaveConfigArgs, returns *Z_SaveConfigReturns) error {
	if hook, ok := s.impl.(interface {
		SaveConfig(config *model.Config) *model.AppError
	}); ok {
		returns.A = hook.SaveConfig(args.A)
	} else {
		return encodableError(fmt.Errorf("API SaveConfig called but not implemented."))
	}
	return nil
}

type Z_GetServerVersionArgs struct {
}

type Z_GetServerVersionReturns struct {
	A string
}

func (g *apiRPCClient) GetServerVersion() string {
	_args := &Z_GetServerVersionArgs{}
	_returns := &Z_GetServerVersionReturns{}
	if err := g.client.Call("Plugin.GetServerVersion", _args, _returns); err != nil {
		log.Printf("RPC call to GetServerVersion API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) GetServerVersion(args *Z_GetServerVersionArgs, returns *Z_GetServerVersionReturns) error {
	if hook, ok := s.impl.(interface {
		GetServerVersion() string
	}); ok {
		returns.A = hook.GetServerVersion()
	} else {
		return encodableError(fmt.Errorf("API GetServerVersion called but not implemented."))
	}
	return nil
}

type Z_CreateUserArgs struct {
	A *model.User
}

type Z_CreateUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) CreateUser(user *model.User) (*model.User, *model.AppError) {
	_args := &Z_CreateUserArgs{user}
	_returns := &Z_CreateUserReturns{}
	if err := g.client.Call("Plugin.CreateUser", _args, _returns); err != nil {
		log.Printf("RPC call to CreateUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateUser(args *Z_CreateUserArgs, returns *Z_CreateUserReturns) error {
	if hook, ok := s.impl.(interface {
		CreateUser(user *model.User) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateUser called but not implemented."))
	}
	return nil
}

type Z_DeleteUserArgs struct {
	A string
}

type Z_DeleteUserReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteUser(userId string) *model.AppError {
	_args := &Z_DeleteUserArgs{userId}
	_returns := &Z_DeleteUserReturns{}
	if err := g.client.Call("Plugin.DeleteUser", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteUser API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteUser(args *Z_DeleteUserArgs, returns *Z_DeleteUserReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteUser(userId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteUser called but not implemented."))
	}
	return nil
}

type Z_GetUserArgs struct {
	A string
}

type Z_GetUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUser(userId string) (*model.User, *model.AppError) {
	_args := &Z_GetUserArgs{userId}
	_returns := &Z_GetUserReturns{}
	if err := g.client.Call("Plugin.GetUser", _args, _returns); err != nil {
		log.Printf("RPC call to GetUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUser(args *Z_GetUserArgs, returns *Z_GetUserReturns) error {
	if hook, ok := s.impl.(interface {
		GetUser(userId string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUser called but not implemented."))
	}
	return nil
}

type Z_GetUserByEmailArgs struct {
	A string
}

type Z_GetUserByEmailReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUserByEmail(email string) (*model.User, *model.AppError) {
	_args := &Z_GetUserByEmailArgs{email}
	_returns := &Z_GetUserByEmailReturns{}
	if err := g.client.Call("Plugin.GetUserByEmail", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserByEmail API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserByEmail(args *Z_GetUserByEmailArgs, returns *Z_GetUserByEmailReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByEmail(email string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByEmail(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserByEmail called but not implemented."))
	}
	return nil
}

type Z_GetUserByUsernameArgs struct {
	A string
}

type Z_GetUserByUsernameReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) GetUserByUsername(name string) (*model.User, *model.AppError) {
	_args := &Z_GetUserByUsernameArgs{name}
	_returns := &Z_GetUserByUsernameReturns{}
	if err := g.client.Call("Plugin.GetUserByUsername", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserByUsername API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserByUsername(args *Z_GetUserByUsernameArgs, returns *Z_GetUserByUsernameReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserByUsername(name string) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserByUsername(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserByUsername called but not implemented."))
	}
	return nil
}

type Z_UpdateUserArgs struct {
	A *model.User
}

type Z_UpdateUserReturns struct {
	A *model.User
	B *model.AppError
}

func (g *apiRPCClient) UpdateUser(user *model.User) (*model.User, *model.AppError) {
	_args := &Z_UpdateUserArgs{user}
	_returns := &Z_UpdateUserReturns{}
	if err := g.client.Call("Plugin.UpdateUser", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUser API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateUser(args *Z_UpdateUserArgs, returns *Z_UpdateUserReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUser(user *model.User) (*model.User, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateUser(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdateUser called but not implemented."))
	}
	return nil
}

type Z_GetUserStatusArgs struct {
	A string
}

type Z_GetUserStatusReturns struct {
	A *model.Status
	B *model.AppError
}

func (g *apiRPCClient) GetUserStatus(userId string) (*model.Status, *model.AppError) {
	_args := &Z_GetUserStatusArgs{userId}
	_returns := &Z_GetUserStatusReturns{}
	if err := g.client.Call("Plugin.GetUserStatus", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserStatus(args *Z_GetUserStatusArgs, returns *Z_GetUserStatusReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserStatus(userId string) (*model.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserStatus(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserStatus called but not implemented."))
	}
	return nil
}

type Z_GetUserStatusesByIdsArgs struct {
	A []string
}

type Z_GetUserStatusesByIdsReturns struct {
	A []*model.Status
	B *model.AppError
}

func (g *apiRPCClient) GetUserStatusesByIds(userIds []string) ([]*model.Status, *model.AppError) {
	_args := &Z_GetUserStatusesByIdsArgs{userIds}
	_returns := &Z_GetUserStatusesByIdsReturns{}
	if err := g.client.Call("Plugin.GetUserStatusesByIds", _args, _returns); err != nil {
		log.Printf("RPC call to GetUserStatusesByIds API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetUserStatusesByIds(args *Z_GetUserStatusesByIdsArgs, returns *Z_GetUserStatusesByIdsReturns) error {
	if hook, ok := s.impl.(interface {
		GetUserStatusesByIds(userIds []string) ([]*model.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetUserStatusesByIds(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetUserStatusesByIds called but not implemented."))
	}
	return nil
}

type Z_UpdateUserStatusArgs struct {
	A string
	B string
}

type Z_UpdateUserStatusReturns struct {
	A *model.Status
	B *model.AppError
}

func (g *apiRPCClient) UpdateUserStatus(userId, status string) (*model.Status, *model.AppError) {
	_args := &Z_UpdateUserStatusArgs{userId, status}
	_returns := &Z_UpdateUserStatusReturns{}
	if err := g.client.Call("Plugin.UpdateUserStatus", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateUserStatus API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateUserStatus(args *Z_UpdateUserStatusArgs, returns *Z_UpdateUserStatusReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateUserStatus(userId, status string) (*model.Status, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateUserStatus(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API UpdateUserStatus called but not implemented."))
	}
	return nil
}

type Z_GetLDAPUserAttributesArgs struct {
	A string
	B []string
}

type Z_GetLDAPUserAttributesReturns struct {
	A map[string]string
	B *model.AppError
}

func (g *apiRPCClient) GetLDAPUserAttributes(userId string, attributes []string) (map[string]string, *model.AppError) {
	_args := &Z_GetLDAPUserAttributesArgs{userId, attributes}
	_returns := &Z_GetLDAPUserAttributesReturns{}
	if err := g.client.Call("Plugin.GetLDAPUserAttributes", _args, _returns); err != nil {
		log.Printf("RPC call to GetLDAPUserAttributes API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetLDAPUserAttributes(args *Z_GetLDAPUserAttributesArgs, returns *Z_GetLDAPUserAttributesReturns) error {
	if hook, ok := s.impl.(interface {
		GetLDAPUserAttributes(userId string, attributes []string) (map[string]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetLDAPUserAttributes(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetLDAPUserAttributes called but not implemented."))
	}
	return nil
}

type Z_CreateTeamArgs struct {
	A *model.Team
}

type Z_CreateTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) CreateTeam(team *model.Team) (*model.Team, *model.AppError) {
	_args := &Z_CreateTeamArgs{team}
	_returns := &Z_CreateTeamReturns{}
	if err := g.client.Call("Plugin.CreateTeam", _args, _returns); err != nil {
		log.Printf("RPC call to CreateTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateTeam(args *Z_CreateTeamArgs, returns *Z_CreateTeamReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeam(team *model.Team) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateTeam called but not implemented."))
	}
	return nil
}

type Z_DeleteTeamArgs struct {
	A string
}

type Z_DeleteTeamReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteTeam(teamId string) *model.AppError {
	_args := &Z_DeleteTeamArgs{teamId}
	_returns := &Z_DeleteTeamReturns{}
	if err := g.client.Call("Plugin.DeleteTeam", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteTeam API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteTeam(args *Z_DeleteTeamArgs, returns *Z_DeleteTeamReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteTeam(teamId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteTeam called but not implemented."))
	}
	return nil
}

type Z_GetTeamsArgs struct {
}

type Z_GetTeamsReturns struct {
	A []*model.Team
	B *model.AppError
}

func (g *apiRPCClient) GetTeams() ([]*model.Team, *model.AppError) {
	_args := &Z_GetTeamsArgs{}
	_returns := &Z_GetTeamsReturns{}
	if err := g.client.Call("Plugin.GetTeams", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeams API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeams(args *Z_GetTeamsArgs, returns *Z_GetTeamsReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeams() ([]*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeams()
	} else {
		return encodableError(fmt.Errorf("API GetTeams called but not implemented."))
	}
	return nil
}

type Z_GetTeamArgs struct {
	A string
}

type Z_GetTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) GetTeam(teamId string) (*model.Team, *model.AppError) {
	_args := &Z_GetTeamArgs{teamId}
	_returns := &Z_GetTeamReturns{}
	if err := g.client.Call("Plugin.GetTeam", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeam(args *Z_GetTeamArgs, returns *Z_GetTeamReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeam(teamId string) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeam called but not implemented."))
	}
	return nil
}

type Z_GetTeamByNameArgs struct {
	A string
}

type Z_GetTeamByNameReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) GetTeamByName(name string) (*model.Team, *model.AppError) {
	_args := &Z_GetTeamByNameArgs{name}
	_returns := &Z_GetTeamByNameReturns{}
	if err := g.client.Call("Plugin.GetTeamByName", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamByName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamByName(args *Z_GetTeamByNameArgs, returns *Z_GetTeamByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamByName(name string) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamByName(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetTeamByName called but not implemented."))
	}
	return nil
}

type Z_UpdateTeamArgs struct {
	A *model.Team
}

type Z_UpdateTeamReturns struct {
	A *model.Team
	B *model.AppError
}

func (g *apiRPCClient) UpdateTeam(team *model.Team) (*model.Team, *model.AppError) {
	_args := &Z_UpdateTeamArgs{team}
	_returns := &Z_UpdateTeamReturns{}
	if err := g.client.Call("Plugin.UpdateTeam", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateTeam(args *Z_UpdateTeamArgs, returns *Z_UpdateTeamReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateTeam(team *model.Team) (*model.Team, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateTeam(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdateTeam called but not implemented."))
	}
	return nil
}

type Z_CreateTeamMemberArgs struct {
	A string
	B string
}

type Z_CreateTeamMemberReturns struct {
	A *model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) CreateTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError) {
	_args := &Z_CreateTeamMemberArgs{teamId, userId}
	_returns := &Z_CreateTeamMemberReturns{}
	if err := g.client.Call("Plugin.CreateTeamMember", _args, _returns); err != nil {
		log.Printf("RPC call to CreateTeamMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateTeamMember(args *Z_CreateTeamMemberArgs, returns *Z_CreateTeamMemberReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeamMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API CreateTeamMember called but not implemented."))
	}
	return nil
}

type Z_CreateTeamMembersArgs struct {
	A string
	B []string
	C string
}

type Z_CreateTeamMembersReturns struct {
	A []*model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) CreateTeamMembers(teamId string, userIds []string, requestorId string) ([]*model.TeamMember, *model.AppError) {
	_args := &Z_CreateTeamMembersArgs{teamId, userIds, requestorId}
	_returns := &Z_CreateTeamMembersReturns{}
	if err := g.client.Call("Plugin.CreateTeamMembers", _args, _returns); err != nil {
		log.Printf("RPC call to CreateTeamMembers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateTeamMembers(args *Z_CreateTeamMembersArgs, returns *Z_CreateTeamMembersReturns) error {
	if hook, ok := s.impl.(interface {
		CreateTeamMembers(teamId string, userIds []string, requestorId string) ([]*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateTeamMembers(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API CreateTeamMembers called but not implemented."))
	}
	return nil
}

type Z_DeleteTeamMemberArgs struct {
	A string
	B string
	C string
}

type Z_DeleteTeamMemberReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteTeamMember(teamId, userId, requestorId string) *model.AppError {
	_args := &Z_DeleteTeamMemberArgs{teamId, userId, requestorId}
	_returns := &Z_DeleteTeamMemberReturns{}
	if err := g.client.Call("Plugin.DeleteTeamMember", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteTeamMember API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteTeamMember(args *Z_DeleteTeamMemberArgs, returns *Z_DeleteTeamMemberReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteTeamMember(teamId, userId, requestorId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteTeamMember(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API DeleteTeamMember called but not implemented."))
	}
	return nil
}

type Z_GetTeamMembersArgs struct {
	A string
	B int
	C int
}

type Z_GetTeamMembersReturns struct {
	A []*model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) GetTeamMembers(teamId string, offset, limit int) ([]*model.TeamMember, *model.AppError) {
	_args := &Z_GetTeamMembersArgs{teamId, offset, limit}
	_returns := &Z_GetTeamMembersReturns{}
	if err := g.client.Call("Plugin.GetTeamMembers", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamMembers API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamMembers(args *Z_GetTeamMembersArgs, returns *Z_GetTeamMembersReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamMembers(teamId string, offset, limit int) ([]*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamMembers(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetTeamMembers called but not implemented."))
	}
	return nil
}

type Z_GetTeamMemberArgs struct {
	A string
	B string
}

type Z_GetTeamMemberReturns struct {
	A *model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) GetTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError) {
	_args := &Z_GetTeamMemberArgs{teamId, userId}
	_returns := &Z_GetTeamMemberReturns{}
	if err := g.client.Call("Plugin.GetTeamMember", _args, _returns); err != nil {
		log.Printf("RPC call to GetTeamMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetTeamMember(args *Z_GetTeamMemberArgs, returns *Z_GetTeamMemberReturns) error {
	if hook, ok := s.impl.(interface {
		GetTeamMember(teamId, userId string) (*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetTeamMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetTeamMember called but not implemented."))
	}
	return nil
}

type Z_UpdateTeamMemberRolesArgs struct {
	A string
	B string
	C string
}

type Z_UpdateTeamMemberRolesReturns struct {
	A *model.TeamMember
	B *model.AppError
}

func (g *apiRPCClient) UpdateTeamMemberRoles(teamId, userId, newRoles string) (*model.TeamMember, *model.AppError) {
	_args := &Z_UpdateTeamMemberRolesArgs{teamId, userId, newRoles}
	_returns := &Z_UpdateTeamMemberRolesReturns{}
	if err := g.client.Call("Plugin.UpdateTeamMemberRoles", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateTeamMemberRoles API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateTeamMemberRoles(args *Z_UpdateTeamMemberRolesArgs, returns *Z_UpdateTeamMemberRolesReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateTeamMemberRoles(teamId, userId, newRoles string) (*model.TeamMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateTeamMemberRoles(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API UpdateTeamMemberRoles called but not implemented."))
	}
	return nil
}

type Z_CreateChannelArgs struct {
	A *model.Channel
}

type Z_CreateChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) CreateChannel(channel *model.Channel) (*model.Channel, *model.AppError) {
	_args := &Z_CreateChannelArgs{channel}
	_returns := &Z_CreateChannelReturns{}
	if err := g.client.Call("Plugin.CreateChannel", _args, _returns); err != nil {
		log.Printf("RPC call to CreateChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreateChannel(args *Z_CreateChannelArgs, returns *Z_CreateChannelReturns) error {
	if hook, ok := s.impl.(interface {
		CreateChannel(channel *model.Channel) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreateChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreateChannel called but not implemented."))
	}
	return nil
}

type Z_DeleteChannelArgs struct {
	A string
}

type Z_DeleteChannelReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteChannel(channelId string) *model.AppError {
	_args := &Z_DeleteChannelArgs{channelId}
	_returns := &Z_DeleteChannelReturns{}
	if err := g.client.Call("Plugin.DeleteChannel", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteChannel API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteChannel(args *Z_DeleteChannelArgs, returns *Z_DeleteChannelReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteChannel(channelId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeleteChannel called but not implemented."))
	}
	return nil
}

type Z_GetPublicChannelsForTeamArgs struct {
	A string
	B int
	C int
}

type Z_GetPublicChannelsForTeamReturns struct {
	A *model.ChannelList
	B *model.AppError
}

func (g *apiRPCClient) GetPublicChannelsForTeam(teamId string, offset, limit int) (*model.ChannelList, *model.AppError) {
	_args := &Z_GetPublicChannelsForTeamArgs{teamId, offset, limit}
	_returns := &Z_GetPublicChannelsForTeamReturns{}
	if err := g.client.Call("Plugin.GetPublicChannelsForTeam", _args, _returns); err != nil {
		log.Printf("RPC call to GetPublicChannelsForTeam API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPublicChannelsForTeam(args *Z_GetPublicChannelsForTeamArgs, returns *Z_GetPublicChannelsForTeamReturns) error {
	if hook, ok := s.impl.(interface {
		GetPublicChannelsForTeam(teamId string, offset, limit int) (*model.ChannelList, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPublicChannelsForTeam(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetPublicChannelsForTeam called but not implemented."))
	}
	return nil
}

type Z_GetChannelArgs struct {
	A string
}

type Z_GetChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetChannel(channelId string) (*model.Channel, *model.AppError) {
	_args := &Z_GetChannelArgs{channelId}
	_returns := &Z_GetChannelReturns{}
	if err := g.client.Call("Plugin.GetChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannel(args *Z_GetChannelArgs, returns *Z_GetChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannel(channelId string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetChannel called but not implemented."))
	}
	return nil
}

type Z_GetChannelByNameArgs struct {
	A string
	B string
	C bool
}

type Z_GetChannelByNameReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetChannelByName(teamId, name string, includeDeleted bool) (*model.Channel, *model.AppError) {
	_args := &Z_GetChannelByNameArgs{teamId, name, includeDeleted}
	_returns := &Z_GetChannelByNameReturns{}
	if err := g.client.Call("Plugin.GetChannelByName", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelByName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelByName(args *Z_GetChannelByNameArgs, returns *Z_GetChannelByNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelByName(teamId, name string, includeDeleted bool) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelByName(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetChannelByName called but not implemented."))
	}
	return nil
}

type Z_GetChannelByNameForTeamNameArgs struct {
	A string
	B string
	C bool
}

type Z_GetChannelByNameForTeamNameReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetChannelByNameForTeamName(teamName, channelName string, includeDeleted bool) (*model.Channel, *model.AppError) {
	_args := &Z_GetChannelByNameForTeamNameArgs{teamName, channelName, includeDeleted}
	_returns := &Z_GetChannelByNameForTeamNameReturns{}
	if err := g.client.Call("Plugin.GetChannelByNameForTeamName", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelByNameForTeamName API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelByNameForTeamName(args *Z_GetChannelByNameForTeamNameArgs, returns *Z_GetChannelByNameForTeamNameReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelByNameForTeamName(teamName, channelName string, includeDeleted bool) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelByNameForTeamName(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API GetChannelByNameForTeamName called but not implemented."))
	}
	return nil
}

type Z_GetDirectChannelArgs struct {
	A string
	B string
}

type Z_GetDirectChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetDirectChannel(userId1, userId2 string) (*model.Channel, *model.AppError) {
	_args := &Z_GetDirectChannelArgs{userId1, userId2}
	_returns := &Z_GetDirectChannelReturns{}
	if err := g.client.Call("Plugin.GetDirectChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetDirectChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetDirectChannel(args *Z_GetDirectChannelArgs, returns *Z_GetDirectChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetDirectChannel(userId1, userId2 string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetDirectChannel(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetDirectChannel called but not implemented."))
	}
	return nil
}

type Z_GetGroupChannelArgs struct {
	A []string
}

type Z_GetGroupChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) GetGroupChannel(userIds []string) (*model.Channel, *model.AppError) {
	_args := &Z_GetGroupChannelArgs{userIds}
	_returns := &Z_GetGroupChannelReturns{}
	if err := g.client.Call("Plugin.GetGroupChannel", _args, _returns); err != nil {
		log.Printf("RPC call to GetGroupChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetGroupChannel(args *Z_GetGroupChannelArgs, returns *Z_GetGroupChannelReturns) error {
	if hook, ok := s.impl.(interface {
		GetGroupChannel(userIds []string) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetGroupChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetGroupChannel called but not implemented."))
	}
	return nil
}

type Z_UpdateChannelArgs struct {
	A *model.Channel
}

type Z_UpdateChannelReturns struct {
	A *model.Channel
	B *model.AppError
}

func (g *apiRPCClient) UpdateChannel(channel *model.Channel) (*model.Channel, *model.AppError) {
	_args := &Z_UpdateChannelArgs{channel}
	_returns := &Z_UpdateChannelReturns{}
	if err := g.client.Call("Plugin.UpdateChannel", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateChannel API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateChannel(args *Z_UpdateChannelArgs, returns *Z_UpdateChannelReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannel(channel *model.Channel) (*model.Channel, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannel(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdateChannel called but not implemented."))
	}
	return nil
}

type Z_AddChannelMemberArgs struct {
	A string
	B string
}

type Z_AddChannelMemberReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) AddChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError) {
	_args := &Z_AddChannelMemberArgs{channelId, userId}
	_returns := &Z_AddChannelMemberReturns{}
	if err := g.client.Call("Plugin.AddChannelMember", _args, _returns); err != nil {
		log.Printf("RPC call to AddChannelMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) AddChannelMember(args *Z_AddChannelMemberArgs, returns *Z_AddChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		AddChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.AddChannelMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API AddChannelMember called but not implemented."))
	}
	return nil
}

type Z_GetChannelMemberArgs struct {
	A string
	B string
}

type Z_GetChannelMemberReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) GetChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError) {
	_args := &Z_GetChannelMemberArgs{channelId, userId}
	_returns := &Z_GetChannelMemberReturns{}
	if err := g.client.Call("Plugin.GetChannelMember", _args, _returns); err != nil {
		log.Printf("RPC call to GetChannelMember API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetChannelMember(args *Z_GetChannelMemberArgs, returns *Z_GetChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		GetChannelMember(channelId, userId string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetChannelMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API GetChannelMember called but not implemented."))
	}
	return nil
}

type Z_UpdateChannelMemberRolesArgs struct {
	A string
	B string
	C string
}

type Z_UpdateChannelMemberRolesReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) UpdateChannelMemberRoles(channelId, userId, newRoles string) (*model.ChannelMember, *model.AppError) {
	_args := &Z_UpdateChannelMemberRolesArgs{channelId, userId, newRoles}
	_returns := &Z_UpdateChannelMemberRolesReturns{}
	if err := g.client.Call("Plugin.UpdateChannelMemberRoles", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateChannelMemberRoles API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateChannelMemberRoles(args *Z_UpdateChannelMemberRolesArgs, returns *Z_UpdateChannelMemberRolesReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannelMemberRoles(channelId, userId, newRoles string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannelMemberRoles(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API UpdateChannelMemberRoles called but not implemented."))
	}
	return nil
}

type Z_UpdateChannelMemberNotificationsArgs struct {
	A string
	B string
	C map[string]string
}

type Z_UpdateChannelMemberNotificationsReturns struct {
	A *model.ChannelMember
	B *model.AppError
}

func (g *apiRPCClient) UpdateChannelMemberNotifications(channelId, userId string, notifications map[string]string) (*model.ChannelMember, *model.AppError) {
	_args := &Z_UpdateChannelMemberNotificationsArgs{channelId, userId, notifications}
	_returns := &Z_UpdateChannelMemberNotificationsReturns{}
	if err := g.client.Call("Plugin.UpdateChannelMemberNotifications", _args, _returns); err != nil {
		log.Printf("RPC call to UpdateChannelMemberNotifications API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdateChannelMemberNotifications(args *Z_UpdateChannelMemberNotificationsArgs, returns *Z_UpdateChannelMemberNotificationsReturns) error {
	if hook, ok := s.impl.(interface {
		UpdateChannelMemberNotifications(channelId, userId string, notifications map[string]string) (*model.ChannelMember, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdateChannelMemberNotifications(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API UpdateChannelMemberNotifications called but not implemented."))
	}
	return nil
}

type Z_DeleteChannelMemberArgs struct {
	A string
	B string
}

type Z_DeleteChannelMemberReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeleteChannelMember(channelId, userId string) *model.AppError {
	_args := &Z_DeleteChannelMemberArgs{channelId, userId}
	_returns := &Z_DeleteChannelMemberReturns{}
	if err := g.client.Call("Plugin.DeleteChannelMember", _args, _returns); err != nil {
		log.Printf("RPC call to DeleteChannelMember API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeleteChannelMember(args *Z_DeleteChannelMemberArgs, returns *Z_DeleteChannelMemberReturns) error {
	if hook, ok := s.impl.(interface {
		DeleteChannelMember(channelId, userId string) *model.AppError
	}); ok {
		returns.A = hook.DeleteChannelMember(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API DeleteChannelMember called but not implemented."))
	}
	return nil
}

type Z_CreatePostArgs struct {
	A *model.Post
}

type Z_CreatePostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *apiRPCClient) CreatePost(post *model.Post) (*model.Post, *model.AppError) {
	_args := &Z_CreatePostArgs{post}
	_returns := &Z_CreatePostReturns{}
	if err := g.client.Call("Plugin.CreatePost", _args, _returns); err != nil {
		log.Printf("RPC call to CreatePost API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CreatePost(args *Z_CreatePostArgs, returns *Z_CreatePostReturns) error {
	if hook, ok := s.impl.(interface {
		CreatePost(post *model.Post) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CreatePost(args.A)
	} else {
		return encodableError(fmt.Errorf("API CreatePost called but not implemented."))
	}
	return nil
}

type Z_AddReactionArgs struct {
	A *model.Reaction
}

type Z_AddReactionReturns struct {
	A *model.Reaction
	B *model.AppError
}

func (g *apiRPCClient) AddReaction(reaction *model.Reaction) (*model.Reaction, *model.AppError) {
	_args := &Z_AddReactionArgs{reaction}
	_returns := &Z_AddReactionReturns{}
	if err := g.client.Call("Plugin.AddReaction", _args, _returns); err != nil {
		log.Printf("RPC call to AddReaction API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) AddReaction(args *Z_AddReactionArgs, returns *Z_AddReactionReturns) error {
	if hook, ok := s.impl.(interface {
		AddReaction(reaction *model.Reaction) (*model.Reaction, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.AddReaction(args.A)
	} else {
		return encodableError(fmt.Errorf("API AddReaction called but not implemented."))
	}
	return nil
}

type Z_RemoveReactionArgs struct {
	A *model.Reaction
}

type Z_RemoveReactionReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) RemoveReaction(reaction *model.Reaction) *model.AppError {
	_args := &Z_RemoveReactionArgs{reaction}
	_returns := &Z_RemoveReactionReturns{}
	if err := g.client.Call("Plugin.RemoveReaction", _args, _returns); err != nil {
		log.Printf("RPC call to RemoveReaction API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) RemoveReaction(args *Z_RemoveReactionArgs, returns *Z_RemoveReactionReturns) error {
	if hook, ok := s.impl.(interface {
		RemoveReaction(reaction *model.Reaction) *model.AppError
	}); ok {
		returns.A = hook.RemoveReaction(args.A)
	} else {
		return encodableError(fmt.Errorf("API RemoveReaction called but not implemented."))
	}
	return nil
}

type Z_GetReactionsArgs struct {
	A string
}

type Z_GetReactionsReturns struct {
	A []*model.Reaction
	B *model.AppError
}

func (g *apiRPCClient) GetReactions(postId string) ([]*model.Reaction, *model.AppError) {
	_args := &Z_GetReactionsArgs{postId}
	_returns := &Z_GetReactionsReturns{}
	if err := g.client.Call("Plugin.GetReactions", _args, _returns); err != nil {
		log.Printf("RPC call to GetReactions API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetReactions(args *Z_GetReactionsArgs, returns *Z_GetReactionsReturns) error {
	if hook, ok := s.impl.(interface {
		GetReactions(postId string) ([]*model.Reaction, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetReactions(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetReactions called but not implemented."))
	}
	return nil
}

type Z_SendEphemeralPostArgs struct {
	A string
	B *model.Post
}

type Z_SendEphemeralPostReturns struct {
	A *model.Post
}

func (g *apiRPCClient) SendEphemeralPost(userId string, post *model.Post) *model.Post {
	_args := &Z_SendEphemeralPostArgs{userId, post}
	_returns := &Z_SendEphemeralPostReturns{}
	if err := g.client.Call("Plugin.SendEphemeralPost", _args, _returns); err != nil {
		log.Printf("RPC call to SendEphemeralPost API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) SendEphemeralPost(args *Z_SendEphemeralPostArgs, returns *Z_SendEphemeralPostReturns) error {
	if hook, ok := s.impl.(interface {
		SendEphemeralPost(userId string, post *model.Post) *model.Post
	}); ok {
		returns.A = hook.SendEphemeralPost(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API SendEphemeralPost called but not implemented."))
	}
	return nil
}

type Z_DeletePostArgs struct {
	A string
}

type Z_DeletePostReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) DeletePost(postId string) *model.AppError {
	_args := &Z_DeletePostArgs{postId}
	_returns := &Z_DeletePostReturns{}
	if err := g.client.Call("Plugin.DeletePost", _args, _returns); err != nil {
		log.Printf("RPC call to DeletePost API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) DeletePost(args *Z_DeletePostArgs, returns *Z_DeletePostReturns) error {
	if hook, ok := s.impl.(interface {
		DeletePost(postId string) *model.AppError
	}); ok {
		returns.A = hook.DeletePost(args.A)
	} else {
		return encodableError(fmt.Errorf("API DeletePost called but not implemented."))
	}
	return nil
}

type Z_GetPostArgs struct {
	A string
}

type Z_GetPostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *apiRPCClient) GetPost(postId string) (*model.Post, *model.AppError) {
	_args := &Z_GetPostArgs{postId}
	_returns := &Z_GetPostReturns{}
	if err := g.client.Call("Plugin.GetPost", _args, _returns); err != nil {
		log.Printf("RPC call to GetPost API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetPost(args *Z_GetPostArgs, returns *Z_GetPostReturns) error {
	if hook, ok := s.impl.(interface {
		GetPost(postId string) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetPost(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetPost called but not implemented."))
	}
	return nil
}

type Z_UpdatePostArgs struct {
	A *model.Post
}

type Z_UpdatePostReturns struct {
	A *model.Post
	B *model.AppError
}

func (g *apiRPCClient) UpdatePost(post *model.Post) (*model.Post, *model.AppError) {
	_args := &Z_UpdatePostArgs{post}
	_returns := &Z_UpdatePostReturns{}
	if err := g.client.Call("Plugin.UpdatePost", _args, _returns); err != nil {
		log.Printf("RPC call to UpdatePost API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) UpdatePost(args *Z_UpdatePostArgs, returns *Z_UpdatePostReturns) error {
	if hook, ok := s.impl.(interface {
		UpdatePost(post *model.Post) (*model.Post, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.UpdatePost(args.A)
	} else {
		return encodableError(fmt.Errorf("API UpdatePost called but not implemented."))
	}
	return nil
}

type Z_CopyFileInfosArgs struct {
	A string
	B []string
}

type Z_CopyFileInfosReturns struct {
	A []string
	B *model.AppError
}

func (g *apiRPCClient) CopyFileInfos(userId string, fileIds []string) ([]string, *model.AppError) {
	_args := &Z_CopyFileInfosArgs{userId, fileIds}
	_returns := &Z_CopyFileInfosReturns{}
	if err := g.client.Call("Plugin.CopyFileInfos", _args, _returns); err != nil {
		log.Printf("RPC call to CopyFileInfos API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) CopyFileInfos(args *Z_CopyFileInfosArgs, returns *Z_CopyFileInfosReturns) error {
	if hook, ok := s.impl.(interface {
		CopyFileInfos(userId string, fileIds []string) ([]string, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.CopyFileInfos(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API CopyFileInfos called but not implemented."))
	}
	return nil
}

type Z_GetFileInfoArgs struct {
	A string
}

type Z_GetFileInfoReturns struct {
	A *model.FileInfo
	B *model.AppError
}

func (g *apiRPCClient) GetFileInfo(fileId string) (*model.FileInfo, *model.AppError) {
	_args := &Z_GetFileInfoArgs{fileId}
	_returns := &Z_GetFileInfoReturns{}
	if err := g.client.Call("Plugin.GetFileInfo", _args, _returns); err != nil {
		log.Printf("RPC call to GetFileInfo API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) GetFileInfo(args *Z_GetFileInfoArgs, returns *Z_GetFileInfoReturns) error {
	if hook, ok := s.impl.(interface {
		GetFileInfo(fileId string) (*model.FileInfo, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.GetFileInfo(args.A)
	} else {
		return encodableError(fmt.Errorf("API GetFileInfo called but not implemented."))
	}
	return nil
}

type Z_ReadFileArgs struct {
	A string
}

type Z_ReadFileReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) ReadFile(path string) ([]byte, *model.AppError) {
	_args := &Z_ReadFileArgs{path}
	_returns := &Z_ReadFileReturns{}
	if err := g.client.Call("Plugin.ReadFile", _args, _returns); err != nil {
		log.Printf("RPC call to ReadFile API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) ReadFile(args *Z_ReadFileArgs, returns *Z_ReadFileReturns) error {
	if hook, ok := s.impl.(interface {
		ReadFile(path string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.ReadFile(args.A)
	} else {
		return encodableError(fmt.Errorf("API ReadFile called but not implemented."))
	}
	return nil
}

type Z_KVSetArgs struct {
	A string
	B []byte
}

type Z_KVSetReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVSet(key string, value []byte) *model.AppError {
	_args := &Z_KVSetArgs{key, value}
	_returns := &Z_KVSetReturns{}
	if err := g.client.Call("Plugin.KVSet", _args, _returns); err != nil {
		log.Printf("RPC call to KVSet API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVSet(args *Z_KVSetArgs, returns *Z_KVSetReturns) error {
	if hook, ok := s.impl.(interface {
		KVSet(key string, value []byte) *model.AppError
	}); ok {
		returns.A = hook.KVSet(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API KVSet called but not implemented."))
	}
	return nil
}

type Z_KVGetArgs struct {
	A string
}

type Z_KVGetReturns struct {
	A []byte
	B *model.AppError
}

func (g *apiRPCClient) KVGet(key string) ([]byte, *model.AppError) {
	_args := &Z_KVGetArgs{key}
	_returns := &Z_KVGetReturns{}
	if err := g.client.Call("Plugin.KVGet", _args, _returns); err != nil {
		log.Printf("RPC call to KVGet API failed: %s", err.Error())
	}
	return _returns.A, _returns.B
}

func (s *apiRPCServer) KVGet(args *Z_KVGetArgs, returns *Z_KVGetReturns) error {
	if hook, ok := s.impl.(interface {
		KVGet(key string) ([]byte, *model.AppError)
	}); ok {
		returns.A, returns.B = hook.KVGet(args.A)
	} else {
		return encodableError(fmt.Errorf("API KVGet called but not implemented."))
	}
	return nil
}

type Z_KVDeleteArgs struct {
	A string
}

type Z_KVDeleteReturns struct {
	A *model.AppError
}

func (g *apiRPCClient) KVDelete(key string) *model.AppError {
	_args := &Z_KVDeleteArgs{key}
	_returns := &Z_KVDeleteReturns{}
	if err := g.client.Call("Plugin.KVDelete", _args, _returns); err != nil {
		log.Printf("RPC call to KVDelete API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) KVDelete(args *Z_KVDeleteArgs, returns *Z_KVDeleteReturns) error {
	if hook, ok := s.impl.(interface {
		KVDelete(key string) *model.AppError
	}); ok {
		returns.A = hook.KVDelete(args.A)
	} else {
		return encodableError(fmt.Errorf("API KVDelete called but not implemented."))
	}
	return nil
}

type Z_PublishWebSocketEventArgs struct {
	A string
	B map[string]interface{}
	C *model.WebsocketBroadcast
}

type Z_PublishWebSocketEventReturns struct {
}

func (g *apiRPCClient) PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast) {
	_args := &Z_PublishWebSocketEventArgs{event, payload, broadcast}
	_returns := &Z_PublishWebSocketEventReturns{}
	if err := g.client.Call("Plugin.PublishWebSocketEvent", _args, _returns); err != nil {
		log.Printf("RPC call to PublishWebSocketEvent API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) PublishWebSocketEvent(args *Z_PublishWebSocketEventArgs, returns *Z_PublishWebSocketEventReturns) error {
	if hook, ok := s.impl.(interface {
		PublishWebSocketEvent(event string, payload map[string]interface{}, broadcast *model.WebsocketBroadcast)
	}); ok {
		hook.PublishWebSocketEvent(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API PublishWebSocketEvent called but not implemented."))
	}
	return nil
}

type Z_HasPermissionToArgs struct {
	A string
	B *model.Permission
}

type Z_HasPermissionToReturns struct {
	A bool
}

func (g *apiRPCClient) HasPermissionTo(userId string, permission *model.Permission) bool {
	_args := &Z_HasPermissionToArgs{userId, permission}
	_returns := &Z_HasPermissionToReturns{}
	if err := g.client.Call("Plugin.HasPermissionTo", _args, _returns); err != nil {
		log.Printf("RPC call to HasPermissionTo API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) HasPermissionTo(args *Z_HasPermissionToArgs, returns *Z_HasPermissionToReturns) error {
	if hook, ok := s.impl.(interface {
		HasPermissionTo(userId string, permission *model.Permission) bool
	}); ok {
		returns.A = hook.HasPermissionTo(args.A, args.B)
	} else {
		return encodableError(fmt.Errorf("API HasPermissionTo called but not implemented."))
	}
	return nil
}

type Z_HasPermissionToTeamArgs struct {
	A string
	B string
	C *model.Permission
}

type Z_HasPermissionToTeamReturns struct {
	A bool
}

func (g *apiRPCClient) HasPermissionToTeam(userId, teamId string, permission *model.Permission) bool {
	_args := &Z_HasPermissionToTeamArgs{userId, teamId, permission}
	_returns := &Z_HasPermissionToTeamReturns{}
	if err := g.client.Call("Plugin.HasPermissionToTeam", _args, _returns); err != nil {
		log.Printf("RPC call to HasPermissionToTeam API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) HasPermissionToTeam(args *Z_HasPermissionToTeamArgs, returns *Z_HasPermissionToTeamReturns) error {
	if hook, ok := s.impl.(interface {
		HasPermissionToTeam(userId, teamId string, permission *model.Permission) bool
	}); ok {
		returns.A = hook.HasPermissionToTeam(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API HasPermissionToTeam called but not implemented."))
	}
	return nil
}

type Z_HasPermissionToChannelArgs struct {
	A string
	B string
	C *model.Permission
}

type Z_HasPermissionToChannelReturns struct {
	A bool
}

func (g *apiRPCClient) HasPermissionToChannel(userId, channelId string, permission *model.Permission) bool {
	_args := &Z_HasPermissionToChannelArgs{userId, channelId, permission}
	_returns := &Z_HasPermissionToChannelReturns{}
	if err := g.client.Call("Plugin.HasPermissionToChannel", _args, _returns); err != nil {
		log.Printf("RPC call to HasPermissionToChannel API failed: %s", err.Error())
	}
	return _returns.A
}

func (s *apiRPCServer) HasPermissionToChannel(args *Z_HasPermissionToChannelArgs, returns *Z_HasPermissionToChannelReturns) error {
	if hook, ok := s.impl.(interface {
		HasPermissionToChannel(userId, channelId string, permission *model.Permission) bool
	}); ok {
		returns.A = hook.HasPermissionToChannel(args.A, args.B, args.C)
	} else {
		return encodableError(fmt.Errorf("API HasPermissionToChannel called but not implemented."))
	}
	return nil
}

type Z_LogDebugArgs struct {
	A string
	B []interface{}
}

type Z_LogDebugReturns struct {
}

func (g *apiRPCClient) LogDebug(msg string, keyValuePairs ...interface{}) {
	_args := &Z_LogDebugArgs{msg, keyValuePairs}
	_returns := &Z_LogDebugReturns{}
	if err := g.client.Call("Plugin.LogDebug", _args, _returns); err != nil {
		log.Printf("RPC call to LogDebug API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) LogDebug(args *Z_LogDebugArgs, returns *Z_LogDebugReturns) error {
	if hook, ok := s.impl.(interface {
		LogDebug(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogDebug(args.A, args.B...)
	} else {
		return encodableError(fmt.Errorf("API LogDebug called but not implemented."))
	}
	return nil
}

type Z_LogInfoArgs struct {
	A string
	B []interface{}
}

type Z_LogInfoReturns struct {
}

func (g *apiRPCClient) LogInfo(msg string, keyValuePairs ...interface{}) {
	_args := &Z_LogInfoArgs{msg, keyValuePairs}
	_returns := &Z_LogInfoReturns{}
	if err := g.client.Call("Plugin.LogInfo", _args, _returns); err != nil {
		log.Printf("RPC call to LogInfo API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) LogInfo(args *Z_LogInfoArgs, returns *Z_LogInfoReturns) error {
	if hook, ok := s.impl.(interface {
		LogInfo(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogInfo(args.A, args.B...)
	} else {
		return encodableError(fmt.Errorf("API LogInfo called but not implemented."))
	}
	return nil
}

type Z_LogErrorArgs struct {
	A string
	B []interface{}
}

type Z_LogErrorReturns struct {
}

func (g *apiRPCClient) LogError(msg string, keyValuePairs ...interface{}) {
	_args := &Z_LogErrorArgs{msg, keyValuePairs}
	_returns := &Z_LogErrorReturns{}
	if err := g.client.Call("Plugin.LogError", _args, _returns); err != nil {
		log.Printf("RPC call to LogError API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) LogError(args *Z_LogErrorArgs, returns *Z_LogErrorReturns) error {
	if hook, ok := s.impl.(interface {
		LogError(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogError(args.A, args.B...)
	} else {
		return encodableError(fmt.Errorf("API LogError called but not implemented."))
	}
	return nil
}

type Z_LogWarnArgs struct {
	A string
	B []interface{}
}

type Z_LogWarnReturns struct {
}

func (g *apiRPCClient) LogWarn(msg string, keyValuePairs ...interface{}) {
	_args := &Z_LogWarnArgs{msg, keyValuePairs}
	_returns := &Z_LogWarnReturns{}
	if err := g.client.Call("Plugin.LogWarn", _args, _returns); err != nil {
		log.Printf("RPC call to LogWarn API failed: %s", err.Error())
	}

}

func (s *apiRPCServer) LogWarn(args *Z_LogWarnArgs, returns *Z_LogWarnReturns) error {
	if hook, ok := s.impl.(interface {
		LogWarn(msg string, keyValuePairs ...interface{})
	}); ok {
		hook.LogWarn(args.A, args.B...)
	} else {
		return encodableError(fmt.Errorf("API LogWarn called but not implemented."))
	}
	return nil
}
